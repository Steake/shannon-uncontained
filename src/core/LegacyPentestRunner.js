import { path, fs, $ } from 'zx';
import chalk from 'chalk';
import dotenv from 'dotenv';

dotenv.config();

// Config and Tools (Adjusted imports for src/core/ location)
import { parseConfig, distributeConfig } from '../config-parser.js';
import { checkToolAvailability } from '../tool-checker.js';

// Session and Checkpoints
import { createSession, updateSession, getSession, AGENTS } from '../session-manager.js';
import { runPhase, getGitCommitHash } from '../checkpoint-manager.js';

// Setup and Deliverables
import { setupLocalRepo } from '../setup/environment.js';

// AI and Prompts
import { runClaudePromptWithRetry } from '../ai/claude-executor.js';
import { loadPrompt } from '../prompts/prompt-manager.js';

// Phases
import { executePreReconPhase } from '../phases/pre-recon.js';
import { assembleFinalReport } from '../phases/reporting.js';

// Utils
import { timingResults, costResults, displayTimingSummary, Timer } from '../utils/metrics.js';
import { formatDuration, generateAuditPath } from '../audit/utils.js';

// Error Handling
import { logError } from '../error-handling.js';

// Session Manager Functions
import {
    calculateVulnerabilityAnalysisSummary,
    calculateExploitationSummary,
    getNextAgent
} from '../session-manager.js';

// Configure zx to disable timeouts
$.timeout = 0;

/**
 * Execute the Legacy Shannon Pentest Pipeline
 * 
 * @param {string} webUrl - Target URL
 * @param {string} repoPath - Local repository path (LSG output)
 * @param {object} options - Options (config, pipelineTestingMode, etc)
 */
export async function runLegacyPentest(webUrl, repoPath, options = {}) {
    const { configPath = null, pipelineTestingMode = false, disableLoader = false } = options;

    // Set global flag for loader control
    global.SHANNON_DISABLE_LOADER = disableLoader;

    const totalTimer = new Timer('total-execution');
    timingResults.total = totalTimer;

    console.log(chalk.cyan.bold('üöÄ STARTING SHANNON PENTEST SYSTEM'));
    console.log(chalk.cyan(`üéØ Target: ${webUrl}`));
    console.log(chalk.cyan(`üìÅ Source: ${repoPath}`));
    console.log(chalk.yellow(`üîß LLM Config: Provider=${process.env.LLM_PROVIDER}, Model=${process.env.LLM_MODEL}, KeyConfigured=${!!process.env.OPENROUTER_API_KEY}`));

    // Parse configuration if provided
    let config = null;
    let distributedConfig = null;
    await (async () => {
        if (configPath) {
            try {
                // Resolve config path - check configs folder if relative path
                let resolvedConfigPath = configPath;
                if (!path.isAbsolute(configPath)) {
                    const configsDir = path.join(process.cwd(), 'configs');
                    const configInConfigsDir = path.join(configsDir, configPath);
                    // Check if file exists in configs directory, otherwise use original path
                    if (await fs.pathExists(configInConfigsDir)) {
                        resolvedConfigPath = configInConfigsDir;
                    }
                }

                config = await parseConfig(resolvedConfigPath);
                distributedConfig = distributeConfig(config);
                console.log(chalk.green(`‚úÖ Configuration loaded successfully`));
            } catch (error) {
                await logError(error, `Configuration loading from ${configPath}`);
                throw error;
            }
        }
    })();

    // Check tool availability
    const toolAvailability = await checkToolAvailability();
    // We don't want to exit process here if missing tools, maybe just log?
    // handleMissingTools(toolAvailability); // This might exit process.
    // Assuming handleMissingTools is safe or we want it to check.
    // The original code called it.

    // Setup local repository
    console.log(chalk.blue('üìÅ Setting up local repository...'));
    let sourceDir;
    try {
        // repoPath is effectively sourceDir in LSG context, but setupLocalRepo might do init/git stuff
        sourceDir = await setupLocalRepo(repoPath);
        console.log(chalk.green('‚úÖ Local repository setup successfully'));
    } catch (error) {
        console.log(chalk.red(`‚ùå Failed to setup local repository: ${error.message}`));
        throw error;
    }

    // Load World Model for Context if available
    let blackboxContext = 'No blackbox context available.';
    try {
        const worldModelPath = path.join(sourceDir, 'world-model.json');
        if (await fs.pathExists(worldModelPath)) {
            const worldModel = await fs.readJson(worldModelPath);
            // Summarize the world model for context
            blackboxContext = `
Targets Identified:
${(worldModel.assets || []).map(a => `- ${a.priority} : ${a.url || a.host}`).join('\n')}

Technology Stack:
${(worldModel.technologies || []).map(t => `- ${t.name} (${t.version || 'no version'})`).join('\n')}

High-Level Architecture:
${worldModel.architecture || 'No architecture details found.'}
`;
        }
    } catch (e) {
        console.warn(chalk.yellow(`‚ö†Ô∏è Failed to load world model context: ${e.message}`));
    }

    // Default empty logic for other context
    const authContext = "No authentication details provided.";
    const githubUrl = "No GitHub URL provided.";

    const variables = {
        webUrl,
        repoPath,
        sourceDir,
        BLACKBOX_CONTEXT: blackboxContext,
        AUTH_CONTEXT: authContext,
        GITHUB_URL: githubUrl
    };

    // Create session for tracking
    const session = await createSession(webUrl, repoPath, configPath, sourceDir);
    console.log(chalk.blue(`üìù Session created: ${session.id.substring(0, 8)}...`));

    // Helper function to update session progress
    const updateSessionProgress = async (agentName, commitHash = null) => {
        try {
            const updates = {
                completedAgents: [...new Set([...session.completedAgents, agentName])],
                failedAgents: session.failedAgents.filter(name => name !== agentName),
                status: 'in-progress'
            };

            if (commitHash) {
                updates.checkpoints = { ...session.checkpoints, [agentName]: commitHash };
            }

            await updateSession(session.id, updates);
            Object.assign(session, updates);
            console.log(chalk.gray(`    üìù Session updated: ${agentName} completed`));
        } catch (error) {
            console.log(chalk.yellow(`    ‚ö†Ô∏è Failed to update session: ${error.message}`));
        }
    };

    try {
        // Create outputs directory in source directory
        const outputsDir = path.join(sourceDir, 'outputs');
        await fs.ensureDir(outputsDir);
        await fs.ensureDir(path.join(outputsDir, 'schemas'));
        await fs.ensureDir(path.join(outputsDir, 'scans'));
    } catch (error) {
        console.warn(`Warning: Failed to create output directories: ${error.message}`);
    }

    // Check if we should continue from where session left off
    const nextAgent = getNextAgent(session);
    if (!nextAgent) {
        console.log(chalk.green(`‚úÖ All agents completed! Session is finished.`));
        await displayTimingSummary();
        return { success: true, finished: true };
    }

    console.log(chalk.blue(`üîÑ Continuing from ${nextAgent.displayName} (${session.completedAgents.length}/${Object.keys(AGENTS).length} agents completed)`));

    // Determine which phase to start from based on next agent
    let startPhase = nextAgent.name === 'pre-recon' ? 1
        : nextAgent.name === 'recon' ? 2
            : ['injection-vuln', 'xss-vuln', 'auth-vuln', 'ssrf-vuln', 'authz-vuln'].includes(nextAgent.name) ? 3
                : ['injection-exploit', 'xss-exploit', 'auth-exploit', 'ssrf-exploit', 'authz-exploit'].includes(nextAgent.name) ? 4
                    : nextAgent.name === 'report' ? 5 : 1;

    console.log(chalk.gray(`    üîß Debug: skipRecon=${options.skipRecon}, startPhase=${startPhase} (nextAgent: ${nextAgent.name})`));

    // Override start phase if skipRecon option is enabled AND we are currently set to start earlier
    if (options.skipRecon === true && startPhase < 3) {
        console.log(chalk.yellow('‚è© Skipping Reconnaissance phases (Pre-Recon & Recon) as requested...'));
        startPhase = 3;

        // Mark skipped agents as completed in session so prerequisites pass for Phase 3
        const skippedAgents = ['pre-recon', 'recon'];
        for (const agent of skippedAgents) {
            if (!session.completedAgents.includes(agent)) {
                await updateSessionProgress(agent);
            }
        }
    }

    // PHASE 1: PRE-RECONNAISSANCE
    if (startPhase <= 1) {
        const { duration: preReconDuration } = await executePreReconPhase(
            webUrl,
            sourceDir,
            variables,
            distributedConfig,
            toolAvailability,
            pipelineTestingMode,
            session.id
        );
        timingResults.phases['pre-recon'] = preReconDuration;
        await updateSessionProgress('pre-recon');
    }

    // PHASE 2: RECONNAISSANCE
    if (startPhase <= 2) {
        console.log(chalk.magenta.bold('\nüîé PHASE 2: RECONNAISSANCE'));
        console.log(chalk.magenta('Analyzing initial findings...'));
        const reconTimer = new Timer('phase-2-recon');
        await runClaudePromptWithRetry(
            await loadPrompt('recon', variables, distributedConfig, pipelineTestingMode),
            sourceDir,
            '*',
            '',
            AGENTS['recon'].displayName,
            'recon',
            chalk.cyan,
            { id: session.id, webUrl }
        );
        const reconDuration = reconTimer.stop();
        timingResults.phases['recon'] = reconDuration;

        console.log(chalk.green(`‚úÖ Reconnaissance complete in ${formatDuration(reconDuration)}`));
        await updateSessionProgress('recon');
    }

    // PHASE 3: VULNERABILITY ANALYSIS
    if (startPhase <= 3) {
        console.log(chalk.red.bold('\nüö® PHASE 3: VULNERABILITY ANALYSIS'));
        const vulnTimer = new Timer('phase-3-vulnerability-analysis');

        await runPhase('vulnerability-analysis', session, pipelineTestingMode, runClaudePromptWithRetry, loadPrompt);

        const currentSession = await getSession(session.id);
        const vulnSummary = calculateVulnerabilityAnalysisSummary(currentSession);
        console.log(chalk.blue(`\nüìä Vulnerability Analysis Summary: ${vulnSummary.totalAnalyses} agents completed`));

        const vulnDuration = vulnTimer.stop();
        timingResults.phases['vulnerability-analysis'] = vulnDuration;
        console.log(chalk.green(`‚úÖ Vulnerability analysis phase complete in ${formatDuration(vulnDuration)}`));
    }

    // PHASE 4: EXPLOITATION
    if (startPhase <= 4) {
        console.log(chalk.red.bold('\nüí• PHASE 4: EXPLOITATION'));
        const exploitTimer = new Timer('phase-4-exploitation');

        const freshSession = await getSession(session.id);
        await runPhase('exploitation', freshSession, pipelineTestingMode, runClaudePromptWithRetry, loadPrompt);

        const finalSession = await getSession(session.id);
        const exploitSummary = calculateExploitationSummary(finalSession);
        console.log(chalk.blue(`\nüéØ Exploitation Summary: ${exploitSummary.totalAttempts} attempted`));

        const exploitDuration = exploitTimer.stop();
        timingResults.phases['exploitation'] = exploitDuration;
        console.log(chalk.green(`‚úÖ Exploitation phase complete in ${formatDuration(exploitDuration)}`));
    }

    // PHASE 5: REPORTING
    if (startPhase <= 5) {
        console.log(chalk.greenBright.bold('\nüìä PHASE 5: REPORTING'));
        const reportTimer = new Timer('phase-5-reporting');

        console.log(chalk.blue('üìù Assembling deliverables...'));
        try {
            await assembleFinalReport(sourceDir);
        } catch (error) {
            console.log(chalk.red(`‚ùå Error assembling final report: ${error.message}`));
        }

        console.log(chalk.blue('üìã Generating executive summary...'));
        await runClaudePromptWithRetry(
            await loadPrompt('report-executive', variables, distributedConfig, pipelineTestingMode),
            sourceDir,
            '*',
            '',
            'Executive Summary and Report Cleanup',
            'report',
            chalk.cyan,
            { id: session.id, webUrl }
        );

        const reportDuration = reportTimer.stop();
        timingResults.phases['reporting'] = reportDuration;

        // Save checkpoint
        try {
            const reportCommitHash = await getGitCommitHash(sourceDir);
            await updateSessionProgress('report', reportCommitHash);
        } catch (error) {
            // ignore
        }
    }

    // Calculate final timing and cost data
    const totalDuration = totalTimer.stop();
    const timingBreakdown = {
        total: totalDuration,
        phases: { ...timingResults.phases },
        agents: { ...timingResults.agents },
        commands: { ...timingResults.commands }
    };
    const costBreakdown = {
        total: costResults.total,
        agents: { ...costResults.agents }
    };

    await updateSession(session.id, {
        status: 'completed',
        timingBreakdown,
        costBreakdown
    });

    // Display comprehensive timing summary
    displayTimingSummary();

    console.log(chalk.cyan.bold('\nüéâ PENETRATION TESTING COMPLETE!'));

    const auditLogsPath = generateAuditPath(session);
    return {
        success: true,
        reportPath: path.join(sourceDir, 'deliverables', 'comprehensive_security_assessment_report.md'),
        auditLogsPath
    };
}
