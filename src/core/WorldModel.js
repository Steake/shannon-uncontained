
import { fs, path } from 'zx';
import crypto from 'crypto';

/**
 * WorldModel - The central source of truth for the agent's knowledge.
 * 
 * Stores:
 * - Evidence: Raw facts observed (scan results, http responses)
 * - Claims: Assertions made by agents based on evidence
 * - Artifacts: Files/Objects generated by agents
 * 
 * Features:
 * - Deterministic serialization (canonical sorting)
 * - Export formats (JSON, JSONL)
 * - Provenance tracking
 */
export class WorldModel {
    constructor(workspaceDir) {
        this.workspaceDir = workspaceDir;
        this.evidence = new Map(); // id -> Evidence
        this.claims = new Map();   // id -> Claim
        this.artifacts = new Map(); // id -> Artifact
        this.relations = []; // { source, target, type }
    }

    /**
     * Initialize the workspace
     */
    async init() {
        if (this.workspaceDir) {
            await fs.ensureDir(this.workspaceDir);
        }
    }

    /**
     * Add a piece of raw evidence
     * @param {Object} data - The evidence data
     * @param {string} sourceAgent - Agent producing the evidence
     * @returns {string} Evidence ID
     */
    addEvidence(data, sourceAgent) {
        const id = this._generateId(data);
        const evidence = {
            id,
            type: 'evidence',
            content: data,
            sourceAgent,
            timestamp: new Date().toISOString()
        };
        this.evidence.set(id, evidence);
        return id;
    }

    /**
     * Add a claim derived from evidence
     * @param {string} subject - What the claim is about
     * @param {string} predicate - The attribute/relation
     * @param {any} object - The value
     * @param {number} confidence - 0.0 to 1.0
     * @param {string[]} evidenceIds - IDs of supporting evidence
     * @returns {string} Claim ID
     */
    addClaim(subject, predicate, object, confidence, evidenceIds = []) {
        const claimData = { subject, predicate, object };
        const id = this._generateId(claimData);

        const claim = {
            id,
            type: 'claim',
            subject,
            predicate,
            object,
            confidence,
            evidenceIds,
            timestamp: new Date().toISOString()
        };

        this.claims.set(id, claim);

        // Link evidence to claim
        evidenceIds.forEach(eid => {
            this.relations.push({ source: eid, target: id, type: 'supports' });
        });

        return id;
    }

    /**
     * Register an artifact
     * @param {string} filePath - Path relative to workspace
     * @param {string} type - Artifact type (report, code, etc)
     * @returns {string} Artifact ID
     */
    addArtifact(filePath, type, metadata = {}) {
        const id = this._generateId({ filePath, type });
        const artifact = {
            id,
            type: 'artifact',
            path: filePath,
            artifactType: type,
            metadata,
            timestamp: new Date().toISOString()
        };
        this.artifacts.set(id, artifact);
        return id;
    }

    /**
     * Export the entire graph to a JSON object
     * @returns {Object}
     */
    toJSON() {
        return {
            evidence: Array.from(this.evidence.values()).sort(this._canonicalSort),
            claims: Array.from(this.claims.values()).sort(this._canonicalSort),
            artifacts: Array.from(this.artifacts.values()).sort(this._canonicalSort),
            relations: this.relations.sort((a, b) =>
                (a.source + a.target).localeCompare(b.source + b.target)
            )
        };
    }

    /**
     * Export to JSON file
     * @param {string} [filename='world-model.json'] 
     */
    async export(filename = 'world-model.json') {
        if (!this.workspaceDir) throw new Error("No workspace directory set");

        const filePath = path.join(this.workspaceDir, filename);
        const data = JSON.stringify(this.toJSON(), null, 2);
        await fs.writeFile(filePath, data);
        return filePath;
    }

    /**
     * Generate a deterministic ID based on content
     * @private
     */
    _generateId(content) {
        const canonical = JSON.stringify(content, Object.keys(content).sort());
        return crypto.createHash('sha256').update(canonical).digest('hex').substring(0, 16);
    }

    /**
     * Sort function for deterministic output
     * @private
     */
    _canonicalSort(a, b) {
        return a.id.localeCompare(b.id);
    }
}
