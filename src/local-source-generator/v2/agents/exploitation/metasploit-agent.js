/**
 * MetasploitAgent - Framework exploitation via msfrpc
 * 
 * Connects to Metasploit RPC daemon to execute auxiliary scanners
 * and exploits based on discovered tech stack.
 */

import { BaseAgent } from '../base-agent.js';
import { CLAIM_TYPES } from '../../epistemics/ledger.js';

// Default msfrpcd connection settings
const DEFAULT_MSFRPC_CONFIG = {
    host: '127.0.0.1',
    port: 55553,
    ssl: true,
    user: 'msf',
    password: 'msf'
};

/**
 * Simple MSFRPC client using fetch
 * Note: Requires msfrpcd running: msfrpcd -P password -S -a 127.0.0.1
 */
class MsfrpcClient {
    constructor(config = {}) {
        this.config = { ...DEFAULT_MSFRPC_CONFIG, ...config };
        this.token = null;
    }

    async connect() {
        const response = await this.call('auth.login', [
            this.config.user,
            this.config.password
        ]);

        if (response?.result === 'success') {
            this.token = response.token;
            return true;
        }
        throw new Error('MSFRPC authentication failed');
    }

    async call(method, params = []) {
        const protocol = this.config.ssl ? 'https' : 'http';
        const url = `${protocol}://${this.config.host}:${this.config.port}/api/`;

        const body = {
            jsonrpc: '2.0',
            method,
            id: Date.now(),
            params: this.token ? [this.token, ...params] : params
        };

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            const data = await response.json();
            return data.result || data;
        } catch (error) {
            throw new Error(`MSFRPC call failed: ${error.message}`);
        }
    }

    async searchModules(query) {
        return this.call('module.search', [query]);
    }

    async getModuleInfo(type, name) {
        return this.call('module.info', [type, name]);
    }

    async executeModule(type, name, options) {
        return this.call('module.execute', [type, name, options]);
    }

    async getJobStatus(jobId) {
        return this.call('job.info', [jobId]);
    }

    async disconnect() {
        if (this.token) {
            await this.call('auth.logout', [this.token]);
            this.token = null;
        }
    }
}

export class MetasploitAgent extends BaseAgent {
    constructor(options = {}) {
        super('MetasploitAgent', options);

        this.inputs_schema = {
            type: 'object',
            required: ['target'],
            properties: {
                target: { type: 'string', description: 'Target host/URL' },
                techStack: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Detected technologies (from TechFingerprinter)'
                },
                msfrpcConfig: {
                    type: 'object',
                    description: 'MSFRPC connection configuration'
                },
                moduleTypes: {
                    type: 'array',
                    items: { type: 'string', enum: ['auxiliary', 'exploit'] },
                    default: ['auxiliary'],
                    description: 'Module types to search'
                },
                maxModules: {
                    type: 'number',
                    default: 10,
                    description: 'Maximum modules to execute'
                }
            }
        };

        this.outputs_schema = {
            type: 'object',
            properties: {
                modulesExecuted: { type: 'array' },
                findings: { type: 'array' },
                connected: { type: 'boolean' }
            }
        };

        this.requires = {
            evidence_kinds: ['tech_fingerprint', 'service_detected'],
            model_nodes: ['technologies', 'services']
        };

        this.emits = {
            evidence_events: ['msf_scan_result', 'exploit_attempt', 'vulnerability_confirmed'],
            model_updates: ['vulnerability_confirmed', 'service_compromised'],
            claims: ['vulnerability_confirmed', 'service_exposed'],
            artifacts: ['metasploit_results.json']
        };

        this.default_budget = {
            max_time_ms: 600000,        // 10 minutes
            max_network_requests: 500,
            max_tokens: 0,
            max_tool_invocations: 50
        };

        // Web-focused auxiliary modules
        this.webScannerModules = [
            'auxiliary/scanner/http/http_login',
            'auxiliary/scanner/http/dir_scanner',
            'auxiliary/scanner/http/robots_txt',
            'auxiliary/scanner/http/http_version',
            'auxiliary/scanner/http/options',
            'auxiliary/scanner/http/trace',
            'auxiliary/scanner/http/verb_auth_bypass',
            'auxiliary/scanner/http/backup_file',
            'auxiliary/scanner/http/files_dir',
            'auxiliary/scanner/http/http_header',
        ];

        // CMS-specific modules
        this.cmsModules = {
            wordpress: [
                'auxiliary/scanner/http/wordpress_scanner',
                'auxiliary/scanner/http/wordpress_login_enum',
            ],
            joomla: [
                'auxiliary/scanner/http/joomla_version',
            ],
            drupal: [
                'auxiliary/scanner/http/drupal_views_user_enum',
            ],
            apache: [
                'auxiliary/scanner/http/apache_optionsbleed',
                'auxiliary/scanner/http/mod_negotiation_scanner',
            ],
            nginx: [
                'auxiliary/scanner/http/nginx_source_disclosure',
            ],
            tomcat: [
                'auxiliary/scanner/http/tomcat_enum',
                'auxiliary/scanner/http/tomcat_mgr_login',
            ]
        };
    }

    /**
     * Select relevant modules based on tech stack
     */
    selectModules(techStack) {
        const modules = new Set(this.webScannerModules);

        // Add CMS-specific modules
        for (const tech of techStack) {
            const techLower = tech.toLowerCase();
            for (const [cms, cmsModules] of Object.entries(this.cmsModules)) {
                if (techLower.includes(cms)) {
                    cmsModules.forEach(m => modules.add(m));
                }
            }
        }

        return Array.from(modules);
    }

    /**
     * Extract host and port from target URL
     */
    parseTarget(target) {
        try {
            const url = new URL(target);
            return {
                host: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                ssl: url.protocol === 'https:',
                uri: url.pathname || '/'
            };
        } catch {
            return { host: target, port: 80, ssl: false, uri: '/' };
        }
    }

    /**
     * Main execution
     */
    async run(ctx, inputs) {
        const {
            target,
            techStack = [],
            msfrpcConfig = {},
            moduleTypes = ['auxiliary'],
            maxModules = 10
        } = inputs;

        const findings = [];
        const modulesExecuted = [];

        // Try to connect to msfrpcd
        const client = new MsfrpcClient(msfrpcConfig);
        let connected = false;

        try {
            await client.connect();
            connected = true;
        } catch (error) {
            // msfrpcd not running - return gracefully
            return {
                connected: false,
                error: `MSFRPC not available: ${error.message}. Start with: msfrpcd -P msf -S -a 127.0.0.1`,
                modulesExecuted: [],
                findings: []
            };
        }

        try {
            const targetInfo = this.parseTarget(target);
            const selectedModules = this.selectModules(techStack).slice(0, maxModules);

            for (const modulePath of selectedModules) {
                ctx.recordToolInvocation();

                try {
                    // Get module info
                    const [type, ...nameParts] = modulePath.split('/');
                    const moduleName = nameParts.join('/');

                    // Set module options
                    const options = {
                        RHOSTS: targetInfo.host,
                        RPORT: targetInfo.port,
                        SSL: targetInfo.ssl,
                        TARGETURI: targetInfo.uri
                    };

                    // Execute module
                    const result = await client.executeModule(type, moduleName, options);

                    modulesExecuted.push({
                        module: modulePath,
                        status: 'executed',
                        jobId: result?.job_id
                    });

                    // If there are results, process them
                    if (result?.data || result?.sessions) {
                        const finding = {
                            module: modulePath,
                            target: target,
                            result: result.data || result,
                            sessions: result.sessions || []
                        };
                        findings.push(finding);

                        // Emit evidence
                        const evidenceId = ctx.emitEvidence({
                            type: 'msf_scan_result',
                            source: this.name,
                            data: finding
                        });

                        // Emit claim
                        ctx.emitClaim({
                            claim_type: 'vulnerability_confirmed',
                            subject: target,
                            predicate: {
                                module: modulePath,
                                result: 'positive'
                            },
                            base_rate: 0.1
                        });

                        // Add EBSL evidence
                        ctx.ledger.addEvidence(
                            ctx.ledger.generateClaimId('vulnerability_confirmed', target),
                            'active_probe_success',
                            1.0,
                            this.name,
                            evidenceId
                        );
                    }

                    ctx.recordNetworkRequest();

                } catch (moduleError) {
                    modulesExecuted.push({
                        module: modulePath,
                        status: 'error',
                        error: moduleError.message
                    });
                }
            }

        } finally {
            await client.disconnect();
        }

        return {
            connected,
            modulesExecuted,
            findings,
            summary: {
                total: modulesExecuted.length,
                successful: modulesExecuted.filter(m => m.status === 'executed').length,
                findings: findings.length
            }
        };
    }
}

export default MetasploitAgent;
