/**
 * MetasploitAgent - Framework exploitation via msfrpc
 * 
 * Connects to Metasploit RPC daemon to execute auxiliary scanners
 * and exploits based on discovered tech stack.
 * 
 * Features:
 * - Managed msfrpcd: Auto-starts the RPC daemon if not running
 * - Dual Mode: 'recon' (auxiliary/scanners) and 'exploitation' (exploits)
 * - Intelligent Module Selection: Tech-stack aware module targetting
 */

import { BaseAgent } from '../base-agent.js';
import { CLAIM_TYPES } from '../../epistemics/ledger.js';
import { spawn } from 'child_process';
import chalk from 'chalk';

// Default msfrpcd connection settings
const DEFAULT_MSFRPC_CONFIG = {
    host: '127.0.0.1',
    port: 55553,
    ssl: true,
    user: 'msf',
    password: 'msf',
    autoStart: true,         // Attempt to auto-start msfrpcd
    startupTimeout: 60000,   // Wait up to 60s for startup
    binPath: 'msfrpcd'       // Path to binary
};

/**
 * Simple MSFRPC client using fetch
 */
class MsfrpcClient {
    constructor(config = {}) {
        this.config = { ...DEFAULT_MSFRPC_CONFIG, ...config };
        this.token = null;
        this.process = null;
        this.manuallyStarted = false;
    }

    /**
     * Check if port is open
     */
    async isPortOpen() {
        try {
            const protocol = this.config.ssl ? 'https' : 'http';
            const url = `${protocol}://${this.config.host}:${this.config.port}/api/`;
            // HEAD request might fail auth (401) but that means port is open
            await fetch(url, {
                method: 'HEAD',
                agent: new (await import('https')).Agent({ rejectUnauthorized: false })
            }).catch(e => {
                if (e.cause?.code === 'ECONNREFUSED') throw e;
            });
            return true;
        } catch (e) {
            if (e.cause?.code === 'ECONNREFUSED') return false;
            // Any other error means the server responded
            return true;
        }
    }

    /**
     * Start msfrpcd process
     */
    async startDaemon() {
        return new Promise((resolve, reject) => {
            console.log(chalk.blue(`  [Metasploit] Starting msfrpcd on port ${this.config.port}...`));

            const args = [
                '-P', this.config.password,
                '-U', this.config.user,
                '-p', this.config.port.toString(),
                '-a', this.config.host,
                '-S', // SSL
                '-f'  // Foreground (so we can control it easier as a child)
            ];

            try {
                this.process = spawn(this.config.binPath, args, {
                    stdio: 'ignore', // Detached mostly
                    detached: false  // Keep attached to parent to kill on exit
                });

                this.manuallyStarted = true;

                this.process.on('error', (err) => {
                    if (err.code === 'ENOENT') {
                        reject(new Error(`msfrpcd binary not found at '${this.config.binPath}'. Is Metasploit installed?`));
                    } else {
                        reject(err);
                    }
                });

                // Wait for port to become available
                let attempts = 0;
                const maxAttempts = this.config.startupTimeout / 1000;

                const checkInterval = setInterval(async () => {
                    attempts++;
                    const isOpen = await this.isPortOpen();
                    if (isOpen) {
                        clearInterval(checkInterval);
                        console.log(chalk.green('  [Metasploit] msfrpcd started successfully.'));
                        // Give it a split second to fully initialize API
                        setTimeout(() => resolve(true), 1000);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                        if (this.process) this.process.kill();
                        reject(new Error('Timed out waiting for msfrpcd to start'));
                    }
                }, 1000);

            } catch (err) {
                reject(err);
            }
        });
    }

    async connect() {
        // Check if running
        let isRunning = await this.isPortOpen();

        // Auto-start if configured and not running
        if (!isRunning && this.config.autoStart) {
            try {
                await this.startDaemon();
                isRunning = true;
            } catch (e) {
                console.log(chalk.yellow(`  [Metasploit] Auto-start failed: ${e.message}`));
                throw e;
            }
        }

        if (!isRunning) {
            throw new Error(`MSFRPC not running on ${this.config.host}:${this.config.port} and auto-start failed or disabled`);
        }

        const response = await this.call('auth.login', [
            this.config.user,
            this.config.password
        ]);

        if (response?.result === 'success') {
            this.token = response.token;
            return true;
        }
        throw new Error('MSFRPC authentication failed');
    }

    async call(method, params = []) {
        const protocol = this.config.ssl ? 'https' : 'http';
        const url = `${protocol}://${this.config.host}:${this.config.port}/api/`;

        const body = {
            jsonrpc: '2.0',
            method,
            id: Date.now(),
            params: this.token ? [this.token, ...params] : params
        };

        try {
            // Self-signed certs are expected
            const agent = new (await import('https')).Agent({ rejectUnauthorized: false });

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
                agent: this.config.ssl ? agent : undefined
            });

            const data = await response.json();
            return data.result || data;
        } catch (error) {
            throw new Error(`MSFRPC call failed: ${error.message}`);
        }
    }

    async executeModule(type, name, options) {
        return this.call('module.execute', [type, name, options]);
    }

    async disconnect() {
        try {
            if (this.token) {
                await this.call('auth.logout', [this.token]).catch(() => { });
                this.token = null;
            }

            // Kill child process if we started it
            if (this.process && this.manuallyStarted) {
                console.log(chalk.gray('  [Metasploit] Stopping managed msfrpcd...'));
                this.process.kill();
                this.process = null;
            }
        } catch (e) {
            // Ignore errors during cleanup
        }
    }
}

export class MetasploitAgent extends BaseAgent {
    constructor(options = {}) {
        // Allow overriding name for "MetasploitRecon" vs "MetasploitExploit"
        const name = options.name || 'MetasploitAgent';
        super(name, options);

        this.defaultMode = options.defaultMode || 'recon'; // recon or exploitation

        this.inputs_schema = {
            type: 'object',
            required: ['target'],
            properties: {
                target: { type: 'string', description: 'Target host/URL' },
                mode: { type: 'string', enum: ['recon', 'exploitation'], default: this.defaultMode },
                techStack: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Detected technologies'
                },
                msfrpcConfig: { type: 'object' },
                maxModules: { type: 'number', default: 10 }
            }
        };

        this.outputs_schema = {
            type: 'object',
            properties: {
                modulesExecuted: { type: 'array' },
                findings: { type: 'array' },
                connected: { type: 'boolean' }
            }
        };

        this.requires = {
            evidence_kinds: ['tech_fingerprint', 'service_detected'],
            model_nodes: ['technologies', 'services']
        };

        this.emits = {
            evidence_events: ['msf_scan_result', 'exploit_attempt', 'vulnerability_confirmed'],
            model_updates: ['vulnerability_confirmed', 'service_compromised', 'service_info'],
            claims: ['vulnerability_confirmed', 'service_exposed', 'info_disclosure'],
            artifacts: ['metasploit_results.json']
        };

        this.default_budget = {
            max_time_ms: 600000,        // 10 minutes
            max_network_requests: 500,
            max_tokens: 0,
            max_tool_invocations: 50
        };

        // --- MODULE CATALOG ---

        // SAFE RECON (Auxiliary Scanners)
        this.reconModules = [
            // General HTTP
            'auxiliary/scanner/http/http_version',
            'auxiliary/scanner/http/robots_txt',
            'auxiliary/scanner/http/title',
            'auxiliary/scanner/http/options',
            'auxiliary/scanner/http/http_header',
            'auxiliary/scanner/http/ssl',
            'auxiliary/scanner/http/cert',
            // Information Disclosure
            'auxiliary/scanner/http/backup_file',
            'auxiliary/scanner/http/files_dir',
            'auxiliary/scanner/http/git_scanner',
            'auxiliary/scanner/http/svn_scanner',
        ];

        // CMS / Tech Specific Recon
        this.techReconModules = {
            wordpress: [
                'auxiliary/scanner/http/wordpress_scanner',
                'auxiliary/scanner/http/wordpress_login_enum',
                'auxiliary/scanner/http/wordpress_user_enum'
            ],
            joomla: ['auxiliary/scanner/http/joomla_version'],
            drupal: ['auxiliary/scanner/http/drupal_views_user_enum'],
            tomcat: ['auxiliary/scanner/http/tomcat_enum', 'auxiliary/scanner/http/tomcat_mgr_login'],
            jenkins: ['auxiliary/scanner/http/jenkins_enum'],
            mysql: ['auxiliary/scanner/mysql/mysql_version', 'auxiliary/scanner/mysql/mysql_login'],
            postgres: ['auxiliary/scanner/postgres/postgres_version'],
            ssh: ['auxiliary/scanner/ssh/ssh_version']
        };

        // EXPLOITATION (Active Exploits & Intrusive Scanners)
        // Only run in exploitation mode
        this.exploitModules = {
            tomcat: ['exploit/multi/http/tomcat_mgr_upload'],
            jenkins: ['exploit/multi/http/jenkins_script_console'],
            wordpress: ['exploit/unix/webapp/wp_admin_shell_upload'],
        };
    }

    /**
     * Select relevant modules based on mode and tech stack
     */
    selectModules(mode, techStack) {
        const modules = new Set();
        const techLower = techStack.map(t => t.toLowerCase());

        if (mode === 'recon') {
            // 1. Add general safe recon modules
            this.reconModules.forEach(m => modules.add(m));

            // 2. Add tech-specific recon
            for (const [techkey, techModules] of Object.entries(this.techReconModules)) {
                if (techLower.some(t => t.includes(techkey))) {
                    techModules.forEach(m => modules.add(m));
                }
            }
        }
        else if (mode === 'exploitation') {
            // 1. Add known exploits for detected tech
            for (const [techkey, techExploits] of Object.entries(this.exploitModules)) {
                if (techLower.some(t => t.includes(techkey))) {
                    techExploits.forEach(m => modules.add(m));
                }
            }
        }

        return Array.from(modules);
    }

    parseTarget(target) {
        try {
            const url = new URL(target);
            return {
                host: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                ssl: url.protocol === 'https:',
                uri: url.pathname || '/'
            };
        } catch {
            return { host: target, port: 80, ssl: false, uri: '/' };
        }
    }

    async run(ctx, inputs) {
        const {
            target,
            mode = this.defaultMode, // Use configured default if not overridden
            techStack = [],
            msfrpcConfig = {},
            maxModules = 20
        } = inputs;

        const client = new MsfrpcClient(msfrpcConfig);
        let connected = false;

        try {
            await client.connect();
            connected = true;
            // console.log(chalk.green(`  [${this.name}] Connected to msfrpcd (${mode} mode)`));
        } catch (error) {
            console.log(chalk.yellow(`  [${this.name}] Skipped: ${error.message}`));
            return {
                connected: false,
                error: error.message,
                modulesExecuted: [],
                findings: []
            };
        }

        const findings = [];
        const modulesExecuted = [];

        try {
            const targetInfo = this.parseTarget(target);
            const selectedModules = this.selectModules(mode, techStack).slice(0, maxModules);

            console.log(chalk.blue(`  [${this.name}] Running ${selectedModules.length} modules (${mode})...`));

            for (const modulePath of selectedModules) {
                // Determine module type
                const [type, ...nameParts] = modulePath.split('/');
                const moduleName = nameParts.join('/');

                // Prepare options
                const options = {
                    RHOSTS: targetInfo.host,
                    RPORT: targetInfo.port,
                    SSL: targetInfo.ssl,
                    TARGETURI: targetInfo.uri,
                    THREADS: 5
                };

                // Only actually run if we have budget
                if (ctx.budget?.toolInvocations >= ctx.config.budget?.max_tool_invocations) {
                    break;
                }
                ctx.recordToolInvocation();

                try {
                    const result = await client.executeModule(type, moduleName, options);

                    modulesExecuted.push({
                        module: modulePath,
                        status: 'executed',
                        jobId: result?.job_id
                    });

                    // Basic check for results
                    if (result && (result.job_id === undefined || result.uuid)) {
                        // Some modules return data directly, others return job_id
                        // This is a simplification. Real implementation needs job polling.
                        // But many scanners return immediately via 'data' in MSFRPC if run inline, 
                        // or we need to poll 'job.info'. 
                    }

                    // For now, tracking execution is the MVP step.
                    // Emitting finding if 'result' contains interesting keys like 'vulns' or 'data'

                } catch (e) {
                    modulesExecuted.push({ module: modulePath, status: 'error', error: e.message });
                }
            }

        } finally {
            await client.disconnect();
        }

        return {
            connected,
            modulesExecuted,
            findings,
            success: true
        };
    }
}

export default MetasploitAgent;
